<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\types\string\string_search.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using JetBrains.Annotations;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.zz;

namespace LamedalCore.Types.String
{
    /// &lt;summary&gt;
    /// Searches a string for a value
    /// &lt;/summary&gt;
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action, DefaultType = typeof(string), GroupName = &quot;Str&quot;)]    
    public sealed class String_Search
    {
        #region var_
        /// &lt;summary&gt;Return the identifier string variable from the input string that is in the form  &#39;Id_Value&#39;. &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;delimiter&quot;&gt;The delimiter setting. Default value = &quot;&quot;.&lt;/param&gt;
        /// &lt;returns&gt;
        /// string
        /// &lt;/returns&gt;
        [Pure]
        public string Var_Id(string inputStr, string delimiter = &quot;♣&quot;)
        {
            return Var_Next(ref inputStr, delimiter);
        }


        /// &lt;summary&gt;Return the next string variable from the input string reference variable in the form &#39;value1,value2,value3&#39;. The seperator character is customisable. &lt;/summary&gt;
        /// &lt;remarks&gt;Recall&lt;/remarks&gt;
        /// &lt;param name=&quot;line&quot;&gt;The inputStr reference variable&lt;/param&gt;
        /// &lt;param name=&quot;delimiter&quot;&gt;The delimiter setting. Default inputStr = &quot;&quot;.&lt;/param&gt;
        /// &lt;param name=&quot;trim&quot;&gt;Trim indicator. Default inputStr = true.&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        [Pure]
        public string Var_Next(ref string line, string delimiter = &quot;♣&quot;, bool trim = true)
        {
            if (System.String.IsNullOrEmpty(line)) return &quot;&quot;;

            if (!line.Contains(delimiter))
            {
                var value = (trim) ? line.Trim() : line;
                line = &quot;&quot;;
                return value;
            }

            var position = line.IndexOf(delimiter);
            var result = line.Substring(0, position);
            if (trim)
            {
                result = result.Trim(&#39; &#39;);
            }
            var length = delimiter.Length;
            line = line.Substring(position + length);
            return result;
        }

        /// &lt;summary&gt;
        /// Return value variable part  from the input string that is in the form &#39;Id_Value&#39;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string&lt;/param&gt;
        /// &lt;param name=&quot;delimiter&quot;&gt;The delimiter setting. Default value = &quot;♣&quot;.&lt;/param&gt;
        /// &lt;param name=&quot;trim&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [trim].&lt;/param&gt;
        /// &lt;returns&gt;
        /// string
        /// &lt;/returns&gt;
        [Pure]
        public string Var_Value(string inputStr, string delimiter = &quot;♣&quot;, bool trim = true)
        {
            if (System.String.IsNullOrEmpty(inputStr)) return &quot;&quot;;
            if (!inputStr.Contains(delimiter)) return &quot;&quot;;

            int position = inputStr.IndexOf(delimiter, System.StringComparison.Ordinal);
            string result = inputStr.Substring(position + delimiter.Length);
            if (trim) result = result.Trim();
            return result;
        }

        /// &lt;summary&gt;Split the line into 3 values.&lt;/summary&gt;
        /// &lt;param name=&quot;line&quot;&gt;The line&lt;/param&gt;
        /// &lt;param name=&quot;val1&quot;&gt;Return the value1&lt;/param&gt;
        /// &lt;param name=&quot;val2&quot;&gt;Return the value to&lt;/param&gt;
        /// &lt;param name=&quot;val3&quot;&gt;Return the value3&lt;/param&gt;
        /// &lt;param name=&quot;delimiter1&quot;&gt;The deleteimiter1 setting. Default value = &quot;-&gt;&quot;.&lt;/param&gt;
        /// &lt;param name=&quot;delimiter2&quot;&gt;The deleteimiter to setting. Default value = &quot;=&gt;&quot;.&lt;/param&gt;
        public void Var_3Values(string line, out string val1, out string val2, out string val3, string delimiter1 = &quot;-&gt;&quot;, string delimiter2 = &quot;=&gt;&quot;)
        {
            var def1 = line;
            val1 = Var_Next(ref def1, delimiter1);
            val2 = Var_Next(ref def1, delimiter2);
            val3 = def1;
        }

        #endregion

        #region Contains
        /// &lt;summary&gt;Determines whether the input (string) contains the search (string) with case sensitivity flag setting.&lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The source&lt;/param&gt;
        /// &lt;param name=&quot;searchValue&quot;&gt;To checks the&lt;/param&gt;
        /// &lt;param name=&quot;comp&quot;&gt;The string comparison&lt;/param&gt;
        /// &lt;returns&gt;bool&lt;/returns&gt;
        public bool Contains(string inputStr, string searchValue, StringComparison comp = StringComparison.OrdinalIgnoreCase)
        {
            return inputStr.IndexOf(searchValue, comp) &gt;= 0;
        }

        /// &lt;summary&gt;
        /// Searches for the item in the text ignoring case and return the found value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text that will be searched&lt;/param&gt;
        /// &lt;param name=&quot;searchItem&quot;&gt;The item searched for&lt;/param&gt;
        /// &lt;param name=&quot;comparisonType&quot;&gt;Type of the comparison.&lt;/param&gt;
        /// &lt;returns&gt;The match that was found in the text&lt;/returns&gt;
        public string Contains_AsStr(string text, string searchItem, StringComparison comparisonType = StringComparison.CurrentCulture)
        {
            var index = text.IndexOf(searchItem, comparisonType);
            if (index == -1) return &quot;&quot;;
            var result = text.Substring(index, searchItem.Length);
            return result;
        }

        /// &lt;summary&gt;
        /// Determines whether the specified input string contains index. This is supposed to be faster than index of
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;searchValue&quot;&gt;The search value.&lt;/param&gt;
        /// &lt;param name=&quot;compare&quot;&gt;The compare.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public int Contains_Index(string inputStr, string searchValue, StringComparison compare = StringComparison.Ordinal)
        {
            //quick check to protect the user from themselves
            if (System.String.IsNullOrEmpty(searchValue) || string.IsNullOrEmpty(inputStr)) return -1;
            return inputStr.IndexOf(searchValue, compare);
        }

        /// &lt;summary&gt;
        /// Determines whether the specified input string contains all searchvalues.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;compare&quot;&gt;The compare.&lt;/param&gt;
        /// &lt;param name=&quot;searchValues&quot;&gt;The search values.&lt;/param&gt;
        /// &lt;returns&gt;
        ///   &lt;c&gt;true&lt;/c&gt; if the specified inputStr contains all; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        [Pure]
        public bool Contains_All(string inputStr, StringComparison compare = StringComparison.OrdinalIgnoreCase, params string[] searchValues)
        {
            foreach (var value in searchValues)
            {
                if (inputStr.IndexOf(value, compare) == -1) return false;
            }
            return true;
        }

        /// &lt;summary&gt;
        /// Determines whether the specified input string contains all searchvalues.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;searchValues&quot;&gt;The search values.&lt;/param&gt;
        /// &lt;returns&gt;
        ///   &lt;c&gt;true&lt;/c&gt; if the specified inputStr contains all; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        [Pure]
        public bool Contains_All(string inputStr, params string[] searchValues)
        {
            return Contains_All(inputStr, StringComparison.OrdinalIgnoreCase, searchValues);
        }

        /// &lt;summary&gt;
        /// Determines whether the specified input string contains any of the search values.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;searchValues&quot;&gt;The search values.&lt;/param&gt;
        /// &lt;returns&gt;
        ///   &lt;c&gt;true&lt;/c&gt; if the specified inputStr contains all; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        [Pure]
        public bool Contains_Any(string inputStr, params string[] searchValues)
        {
            string findValue;
            return Contains_Any(inputStr, out findValue, StringComparison.CurrentCulture, searchValues);
        }
        /// &lt;summary&gt;
        /// Determines whether the specified input string contains any of the search values.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;comparisonType&quot;&gt;Type of the comparison.&lt;/param&gt;
        /// &lt;param name=&quot;searchValues&quot;&gt;The search values.&lt;/param&gt;
        /// &lt;returns&gt;
        ///   &lt;c&gt;true&lt;/c&gt; if the specified inputStr contains all; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        [Pure]
        public bool Contains_Any(string inputStr, StringComparison comparisonType = StringComparison.CurrentCulture, params string[] searchValues)
        {
            string findValue;
            return Contains_Any(inputStr, out findValue, comparisonType, searchValues);
        }
        /// &lt;summary&gt;
        /// Determines whether the specified input string contains any of the search values. Returns true if found as well at the value that was found.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The input string.&lt;/param&gt;
        /// &lt;param name=&quot;findValue&quot;&gt;The find value.&lt;/param&gt;
        /// &lt;param name=&quot;comparisonType&quot;&gt;Type of the comparison.&lt;/param&gt;
        /// &lt;param name=&quot;searchValues&quot;&gt;The search values.&lt;/param&gt;
        /// &lt;returns&gt;
        ///   &lt;c&gt;true&lt;/c&gt; if the specified inputStr contains all; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        [Pure]
        public bool Contains_Any(string text, out string findValue, StringComparison comparisonType = StringComparison.CurrentCulture, params string[] searchValues)
        {
            findValue = &quot;&quot;;
            foreach (var value in searchValues)
            {
                findValue = Contains_AsStr(text, value, comparisonType);
                if (findValue != &quot;&quot;) return true;
            }
            return false;
        }
        #endregion

        #region Equal
        /// &lt;summary&gt;
        /// Determines whether the value is in the compare values array.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value&lt;/param&gt;
        /// &lt;param name=&quot;compareValues&quot;&gt;The compare values array&lt;/param&gt;
        /// &lt;returns&gt;bool&lt;/returns&gt;
        public bool Equal_In(string value, params string[] compareValues)
        {
            foreach (string compareValue in compareValues)
            {
                if (value == compareValue) return true;
            }
            return false;
        }

        /// &lt;summary&gt;Percent value1 is equal to value2.&lt;/summary&gt;
        /// &lt;param name=&quot;value1&quot;&gt;The valueue1&lt;/param&gt;
        /// &lt;param name=&quot;value2&quot;&gt;The valueue to&lt;/param&gt;
        /// &lt;returns&gt;double&lt;/returns&gt;
        public double Equal_Percent(string value1, string value2)
        {
            if (value1 == value2) return 100;
            if ((value1.Length == 0) || (value2.Length == 0)) return 0;

            double total = value1.Length &gt; value2.Length ? value1.Length : value2.Length;
            int min = value1.Length &lt; value2.Length ? value1.Length : value2.Length;
            int isMatch = 0;
            for (int i = 0; i &lt; min; i++) if (value1[i] == value2[i]) isMatch++;  //Compare char by char
            var percent = isMatch / total * 100;
            return percent;
        }

        /// &lt;summary&gt;Show the difference between two strings at index.&lt;/summary&gt;
        /// &lt;param name=&quot;str1&quot;&gt;The string1&lt;/param&gt;
        /// &lt;param name=&quot;str2&quot;&gt;The string to&lt;/param&gt;
        /// &lt;param name=&quot;index&quot;&gt;The index to&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public string Equal_StrError(string str1, string str2, int index)
        {
            string errorMsg = &quot;Values differ at pos = {0}.&quot;.NL(2);
            errorMsg += &quot;Value1: &#39;{1}&#39; != &quot;.NL();
            errorMsg += &quot;Value2: &#39;{2}&#39;; &quot;.NL();
            errorMsg = errorMsg.zFormat(index, str1, str2);
            if (index &gt; 0) errorMsg += &quot;Diff??: &quot; + &quot;-&quot;.zRepeat(index) + &quot;^&quot;;
            return errorMsg;
        }

        /// &lt;summary&gt;
        /// Determines whether the value1 string is equal to value2.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value1&quot;&gt;The value1&lt;/param&gt;
        /// &lt;param name=&quot;value2&quot;&gt;The value to&lt;/param&gt;
        /// &lt;param name=&quot;errorMsg&quot;&gt;Return the error msg&lt;/param&gt;
        /// &lt;param name=&quot;index&quot;&gt;The index where the two strings differ&lt;/param&gt;
        /// &lt;returns&gt;bool&lt;/returns&gt;
        public bool Equal_(string value1, string value2, out string errorMsg, out int index)
        {
            index = 0;
            errorMsg = &quot;&quot;;
            if (value1 == value2) return true;

            if ((value1.Length != 0) &amp;&amp; (value2.Length != 0))
            {
                //double maxLen = value1.Length &gt; value2.Length ? value1.Length : value2.Length;
                int minLen = value1.Length &lt; value2.Length ? value1.Length : value2.Length;
                //int isMatch = 0;
                for (int i = 0; i &lt; minLen; i++) //Compare char by char
                {
                    index++;
                    if (value1[i] != value2[i]) break;
                }
            }

            errorMsg = Equal_StrError(value1, value2, index);
            return false;
        }
        #endregion

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,9,27,10,1],[28,13,28,54,1],[29,9,29,10,1],[40,9,40,10,1],[41,13,41,51,1],[41,52,41,62,1],[43,13,43,43,1],[44,13,44,14,1],[45,17,45,57,1],[46,17,46,27,1],[47,17,47,30,1],[50,13,50,52,1],[51,13,51,54,1],[52,13,52,22,1],[53,13,53,14,1],[54,17,54,43,1],[55,13,55,14,1],[56,13,56,43,1],[57,13,57,54,1],[58,13,58,27,1],[59,9,59,10,1],[72,9,72,10,1],[73,13,73,55,1],[73,56,73,66,1],[74,13,74,47,1],[74,48,74,58,1],[76,13,76,89,1],[77,13,77,77,1],[78,13,78,22,1],[78,23,78,46,1],[79,13,79,27,1],[80,9,80,10,1],[90,9,90,10,1],[91,13,91,29,1],[92,13,92,51,1],[93,13,93,51,1],[94,13,94,25,1],[95,9,95,10,1],[106,9,106,10,1],[107,13,107,61,1],[108,9,108,10,1],[118,9,118,10,1],[119,13,119,66,1],[120,13,120,29,1],[120,30,120,40,1],[121,13,121,67,1],[122,13,122,27,1],[123,9,123,10,1],[133,9,133,10,1],[135,13,135,92,1],[135,93,135,103,1],[136,13,136,59,1],[137,9,137,10,1],[150,9,150,10,1],[151,13,151,20,1],[151,35,151,47,1],[151,22,151,31,1],[152,13,152,14,1],[153,17,153,60,1],[153,61,153,74,1],[154,13,154,14,1],[151,32,151,34,1],[155,13,155,25,1],[156,9,156,10,1],[168,9,168,10,1],[169,13,169,93,1],[170,9,170,10,1],[182,9,182,10,1],[184,13,184,105,1],[185,9,185,10,1],[197,9,197,10,1],[199,13,199,88,1],[200,9,200,10,1],[213,9,213,10,1],[214,13,214,28,1],[215,13,215,20,1],[215,35,215,47,1],[215,22,215,31,1],[216,13,216,14,1],[217,17,217,73,1],[218,17,218,37,1],[218,38,218,50,1],[219,13,219,14,1],[215,32,215,34,1],[220,13,220,26,1],[221,9,221,10,1],[232,9,232,10,1],[233,13,233,20,1],[233,45,233,58,1],[233,22,233,41,1],[234,13,234,14,1],[235,17,235,43,1],[235,44,235,56,1],[236,13,236,14,1],[233,42,233,44,1],[237,13,237,26,1],[238,9,238,10,1],[245,9,245,10,1],[246,13,246,34,1],[246,35,246,46,1],[247,13,247,62,1],[247,63,247,72,1],[249,13,249,90,1],[250,13,250,85,1],[251,13,251,29,1],[252,18,252,27,1],[252,43,252,70,1],[252,71,252,81,1],[252,38,252,41,1],[252,29,252,36,1],[253,13,253,49,1],[254,13,254,28,1],[255,9,255,10,1],[263,9,263,10,1],[264,13,264,67,1],[265,13,265,50,1],[266,13,266,48,1],[267,13,267,60,1],[268,13,268,27,1],[268,28,268,78,1],[269,13,269,29,1],[270,9,270,10,1],[281,9,281,10,1],[282,13,282,23,1],[283,13,283,27,1],[284,13,284,34,1],[284,35,284,47,1],[286,13,286,62,1],[287,13,287,14,1],[289,17,289,92,1],[291,22,291,31,1],[292,17,292,18,1],[293,21,293,29,1],[294,21,294,48,1],[294,49,294,55,1],[295,17,295,18,1],[291,45,291,48,1],[291,33,291,43,1],[296,13,296,14,1],[298,13,298,62,1],[299,13,299,26,1],[300,9,300,10,1]]);
    </script>
  </body>
</html>