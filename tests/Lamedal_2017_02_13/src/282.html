<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\lib\xml\xml_mindmap.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.zz;

namespace LamedalCore.lib.XML
{
    /// &lt;summary&gt;
    /// Mindmap is very specific. No CTI network generated currently
    /// &lt;/summary&gt;
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action)]
    public sealed class XML_Mindmap
    {
        private readonly LamedalCore_ _lamed = LamedalCore_.Instance;

        /// &lt;summary&gt;
        /// Converts the XML mindmap to node string list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;XML&quot;&gt;The XML&lt;/param&gt;
        /// &lt;param name=&quot;addId&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [add identifier].&lt;/param&gt;
        /// &lt;returns&gt;
        /// List&lt;string /&gt;
        /// &lt;/returns&gt;
        public List&lt;string&gt; TreeStrList_FromXML(string XML, bool addId = false)
        {
            var mm = _lamed.lib.XML.xDoc.Document(XML);
            var mapElement = mm.zxDoc_Element_Root(); // map

            var nodeList = new List&lt;string&gt;();
            var nodeDictionary = new Dictionary&lt;string, XElement&gt;();

            var rootElement = mapElement.zxDoc_Element_(&quot;node&quot;); // Root
            var rootStr = rootElement.zxDoc_Attribute_AsStr(&quot;TEXT&quot;);
            var id = rootElement.zxDoc_Attribute_AsStr(&quot;ID&quot;).Substring(3);

             if (addId)
                  nodeList.Add(id + &quot;:&quot; + rootStr);
             else nodeList.Add(rootStr);
            nodeDictionary.Add(rootStr, rootElement);

            NodeStringList_AddNode(nodeList, nodeDictionary, &quot;&quot;, rootElement, addId);
            return nodeList;
        }

        /// &lt;summary&gt;
        /// Creates the mind map xdoc from the node string list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;treeStringList&quot;&gt;The node list&lt;/param&gt;
        /// &lt;param name=&quot;addId&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [add identifier].&lt;/param&gt;
        /// &lt;returns&gt;
        /// XDocument
        /// &lt;/returns&gt;
        public XDocument TreeStrList_2XmlDocument(List&lt;string&gt; treeStringList, bool addId = false)
        {
            if (treeStringList.Count == 0) return null;

            // From the nodeList create the XML document
            var nodeDictionary = new Dictionary&lt;string, XElement&gt;();
            var pathMissing = new List&lt;string&gt;();
            // Create the map element
            var xDoc = new XDocument();
            var map = xDoc.zxDoc_Element_RootSet(&quot;map&quot;);
            map.zxDoc_Attribute_Set(&quot;version&quot;, &quot;1.0.1&quot;);

            // Create the first element
            var id = 1;
            var nodeName = treeStringList[0];
            if (addId) treeStringList[0] = id + &quot;:&quot; + treeStringList[0];
            var nodeElement = _xDoc_NodeElementAdd(map, nodeName, id++);
            nodeElement.zxDoc_Attribute_Set(&quot;STYLE&quot;, &quot;bubble&quot;);
            nodeDictionary.Add(nodeName, nodeElement);

            // Create the rest
            for (var ii = 1; ii &lt;= treeStringList.Count - 1; ii++)
            {
                //if (ii == 129)
                //    &quot;stop&quot;.zOk();
                nodeName = treeStringList[ii];
                if (nodeDictionary.ContainsKey(nodeName)) continue; // &lt;==========================[This item is already generated

                if (nodeName.Contains(&quot;.csproj:Properties:AssemblyInfo.cs&quot;)) continue;  //&lt;===============================[ Do not include this file

                string firstPart, lastPart;
                var parentElement = xDoc_FindParent(nodeName, nodeDictionary, out firstPart, out lastPart);

                if (parentElement == null)
                {
                    // Parent element was not found in the firstPart -&gt; We need to make sure the full path exists.
                    var folders = nodeName.zConvert_Array_FromStr(&quot;:&quot;).ToList();
                    var root = &quot;&quot;;
                    var item0 = &quot;&quot;;
                    for (var jj = 0; jj &lt; folders.Count; jj++)
                    {
                        // Reconstruct the full path and make sure every part of the path exists. 
                        var parent = parentElement;
                        var item1 = folders[jj];
                        folders[jj] = root + item1;
                        root += item1 + &quot;:&quot;;
                        if (jj == 0)
                        {
                            item0 = item1;  // Save the folder for reference later
                            continue; // Skip the first folder -&gt; this ensures that there is a first part.
                        }

                        string firstPart2, lastPart2;
                        parentElement = xDoc_FindParent(folders[jj], nodeDictionary, out firstPart2, out lastPart2);
                        if (parentElement == null)
                        {
                            // This part of the path does not exists yet -&gt; Create the folder element 
                            if (addId) pathMissing.Add(id + &quot;:&quot; + firstPart2);
                            else pathMissing.Add(firstPart2);

                            parentElement = _xDoc_NodeElementAdd(parent, item0, id++);
                            nodeDictionary.Add(firstPart2, parentElement);
                        }
                        item0 = item1; // Save the folder for reference later
                    }
                }

                if (addId) treeStringList[ii] = id + &quot;:&quot; + treeStringList[ii];
                nodeElement = _xDoc_NodeElementAdd(parentElement, lastPart, id++);
                nodeDictionary.Add(nodeName, nodeElement);
            }

            treeStringList.AddRange(pathMissing);
            return xDoc;
        }
                
        #region Private

        /// &lt;summary&gt;Adds the node from the mindmap to the string list.&lt;/summary&gt;
        private void NodeStringList_AddNode(List&lt;string&gt; nodeList, Dictionary&lt;string, XElement&gt; nodeDictionary, string root, XElement node, bool addId = false)
        {
            if (node == null) return;

            var nodeStr = node.zxDoc_Attribute_AsStr(&quot;TEXT&quot;);
            root = root + nodeStr + &quot;:&quot;;
            var nodes = node.Elements(&quot;node&quot;).ToList();
            foreach (var node1 in nodes)
            {
                var value = node1.zxDoc_Attribute_AsStr(&quot;TEXT&quot;);
                var id = node1.zxDoc_Attribute_AsStr(&quot;ID&quot;).Substring(3);

                if (addId) 
                     nodeList.Add(id + &quot;:&quot; + root + value);
                else nodeList.Add(root + value);
                nodeDictionary.Add(root + value, node1);
                NodeStringList_AddNode(nodeList, nodeDictionary, root, node1, addId); //&lt;&lt;===================[Recursion
            }
        }

        private XElement xDoc_FindParent(string nodeName, Dictionary&lt;string, XElement&gt; nodeDictionary,
            out string firstPart, out string lastPart)
        {
            _lamed.Types.String.Word.Word_SplitOnLast(nodeName, out firstPart, out lastPart, &quot;:&quot;);
            XElement parentElement;
            nodeDictionary.TryGetValue(firstPart, out parentElement);
            return parentElement;
        }

        /// &lt;summary&gt;Adds the node element to the parent element.&lt;/summary&gt;
        public XElement _xDoc_NodeElementAdd(XElement parentElement, string value, int id, bool right = false, bool folded = false)
        {
            if (parentElement == null)
            {
                &quot;Error! The parent element can not be undefined!&quot;.zException_Show();
                return null;
            }
            // parent
            var parentStr = parentElement.zxDoc_Attribute_AsStr(&quot;TEXT&quot;);
            if (parentStr.Contains(&quot;.csproj&quot;) || value.Contains(&quot;.cs&quot;)) folded = true;   // Fold first level elements

            // node
            var element = parentElement.zxDoc_Element_Add(&quot;node&quot;);
            element.zxDoc_Attribute_Set(&quot;ID&quot;, &quot;ID_&quot; + id.zTo_Str().Trim());
            if (right) element.zxDoc_Attribute_Set(&quot;POSITION&quot;, &quot;right&quot;);
            if (folded) element.zxDoc_Attribute_Set(&quot;FOLDED&quot;, &quot;true&quot;);
            element.zxDoc_Attribute_Set(&quot;TEXT&quot;, value);

            // Icon
            var icon = enFreemindIcon.folder;
            if (id == 1)
            {
                icon = enFreemindIcon.gohome;

                //&lt;font BOLD=&quot;true&quot; NAME=&quot;SansSerif&quot; SIZE=&quot;20&quot;/&gt;
                XElement_AddFont(element, &quot;SansSerif&quot;, 20, true);
            }
            else if (value.Contains(&quot;.csproj&quot;))
            {
                icon = enFreemindIcon.launch;
                // &lt;font BOLD=&quot;true&quot; NAME=&quot;SansSerif&quot; SIZE=&quot;16&quot;/&gt;
                XElement_AddFont(element, &quot;SansSerif&quot;, 16, true);
            }
            else if (value.zContains_Any(&quot;.cs&quot;, &quot;.doc&quot;, &quot;.docx&quot;, &quot;.xlsx&quot;, &quot;.pptx&quot;, &quot;.avi&quot;, &quot;.flv&quot;, &quot;.pdf&quot;, &quot;.ppt&quot;, &quot;.png&quot;,
                &quot;.chm&quot;, &quot;.gui&quot;, &quot;*.jpg&quot;)) icon = enFreemindIcon.idea;
            else if (value.zContains_All(&quot;(&quot;, &quot;)&quot;)) icon = enFreemindIcon.xmag;
            else if (value.Contains(&quot;- &quot;)) icon = enFreemindIcon.help;

            XElement_AddIcon(element, icon);

            return element;
        }

        private static void XElement_AddFont(XElement element, string fontName, int size, bool bold = false)
        {
            // Adds font to the node
            var fontElement = element.zxDoc_Element_Add(&quot;font&quot;);
            fontElement.zxDoc_Attribute_Set(&quot;NAME&quot;, fontName);
            if (bold) fontElement.zxDoc_Attribute_Set(&quot;BOLD&quot;, &quot;true&quot;);
            fontElement.zxDoc_Attribute_Set(&quot;SIZE&quot;, size.zTo_Str());
        }

        private void XElement_AddIcon(XElement element, enFreemindIcon icon)
        {
            var iconElement = element.zxDoc_Element_Add(&quot;icon&quot;);
            iconElement.zxDoc_Attribute_Set(&quot;BUILTIN&quot;, (icon.zTo_Description()));
        }



        #endregion


    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[39,19,39,52,0],[57,44,57,56,0],[70,24,70,73,0],[81,59,81,68,0],[83,78,83,87,0],[89,17,89,18,0],[91,21,91,81,0],[92,21,92,35,0],[93,21,93,36,0],[94,26,94,36,0],[95,21,95,22,0],[97,25,97,52,0],[98,25,98,49,0],[99,25,99,52,0],[100,25,100,45,0],[101,25,101,37,0],[102,25,102,26,0],[103,29,103,43,0],[104,29,104,38,0],[108,25,108,117,0],[109,25,109,51,0],[110,25,110,26,0],[112,29,112,39,0],[112,40,112,79,0],[113,34,113,62,0],[115,29,115,87,0],[116,29,116,75,0],[117,25,117,26,0],[118,25,118,39,0],[119,21,119,22,0],[94,58,94,62,0],[94,38,94,56,0],[120,17,120,18,0],[122,28,122,79,0],[136,31,136,38,0],[147,22,147,60,0],[167,13,167,14,0],[168,17,168,85,0],[169,17,169,29,0],[27,9,27,10,1],[28,13,28,56,1],[29,13,29,54,1],[31,13,31,47,1],[32,13,32,69,1],[34,13,34,65,1],[35,13,35,69,1],[36,13,36,75,1],[38,14,38,24,1],[40,19,40,41,1],[41,13,41,54,1],[43,13,43,86,1],[44,13,44,29,1],[45,9,45,10,1],[56,9,56,10,1],[57,13,57,43,1],[60,13,60,69,1],[61,13,61,50,1],[63,13,63,40,1],[64,13,64,57,1],[65,13,65,57,1],[68,13,68,24,1],[69,13,69,46,1],[70,13,70,23,1],[71,13,71,73,1],[72,13,72,64,1],[73,13,73,55,1],[76,18,76,28,1],[77,13,77,14,1],[80,17,80,47,1],[81,17,81,58,1],[83,17,83,77,1],[86,17,86,108,1],[88,17,88,43,1],[122,17,122,27,1],[123,17,123,83,1],[124,17,124,59,1],[125,13,125,14,1],[76,62,76,66,1],[76,30,76,60,1],[127,13,127,50,1],[128,13,128,25,1],[129,9,129,10,1],[135,9,135,10,1],[136,13,136,30,1],[138,13,138,62,1],[139,13,139,41,1],[140,13,140,56,1],[141,13,141,20,1],[141,35,141,40,1],[141,22,141,31,1],[142,13,142,14,1],[143,17,143,65,1],[144,17,144,73,1],[146,17,146,27,1],[148,22,148,49,1],[149,17,149,57,1],[150,17,150,86,1],[151,13,151,14,1],[141,32,141,34,1],[152,9,152,10,1],[156,9,156,10,1],[157,13,157,99,1],[159,13,159,70,1],[160,13,160,34,1],[161,9,161,10,1],[165,9,165,10,1],[166,13,166,39,1],[172,13,172,73,1],[173,13,173,72,1],[173,73,173,87,1],[176,13,176,67,1],[177,13,177,76,1],[178,13,178,23,1],[178,24,178,73,1],[179,13,179,24,1],[179,25,179,71,1],[180,13,180,56,1],[183,13,183,46,1],[184,13,184,25,1],[185,13,185,14,1],[186,17,186,46,1],[189,17,189,66,1],[190,13,190,14,1],[191,18,191,48,1],[192,13,192,14,1],[193,17,193,46,1],[195,17,195,66,1],[196,13,196,14,1],[197,18,198,42,1],[198,43,198,70,1],[199,18,199,52,1],[199,53,199,80,1],[200,18,200,43,1],[200,44,200,71,1],[202,13,202,45,1],[204,13,204,28,1],[205,9,205,10,1],[208,9,208,10,1],[210,13,210,65,1],[211,13,211,63,1],[212,13,212,22,1],[212,23,212,71,1],[213,13,213,69,1],[214,9,214,10,1],[217,9,217,10,1],[218,13,218,65,1],[219,13,219,82,1],[220,9,220,10,1],[16,9,16,70,1]]);
    </script>
  </body>
</html>