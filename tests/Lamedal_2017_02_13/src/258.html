<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\types\string\string_regex.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using JetBrains.Annotations;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.zz;

namespace LamedalCore.Types.String
{
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action, DefaultType = typeof(string), GroupName = &quot;Str&quot;)]
    public sealed class String_Regex
    {
        /// &lt;summary&gt;
        /// Test if &#39;inputStr&#39; is Alpha.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The @inputStr to act on.&lt;/param&gt;
        /// &lt;returns&gt;true if Alpha, false if not.&lt;/returns&gt;
        public bool IsAlpha(string inputStr)
        {
            var regex = new Regex(@&quot;[^a-zA-Z]&quot;);
            var match = regex.Match(inputStr);
            return !match.Success;
        }

        /// &lt;summary&gt;
        /// Indicates whether the current string matches the supplied wildcard pattern.  Behaves the same
        /// as VB&#39;s &quot;Like&quot; Operator.
        /// http://stackoverflow.com/questions/271398/what-are-your-favorite-extension-methods-for-c-codeplex-com-extensionoverflow?page=2&amp;tab=votes#tab-top
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string instance where the extension method is called&lt;/param&gt;
        /// &lt;param name=&quot;wildcardPattern&quot;&gt;The wildcard pattern to match.  Syntax matches VB&#39;s Like operator.&lt;/param&gt;
        /// &lt;returns&gt;true if the string matches the supplied pattern, false otherwise.&lt;/returns&gt;
        /// &lt;remarks&gt;See http://msdn.microsoft.com/en-us/library/swf8kaxw(v=VS.100).aspx&lt;/remarks&gt;
        public bool IsLike(string text, string wildcardPattern)
        {
            if (text.zIsNullOrEmpty()) return false;
            if (wildcardPattern.zIsNullOrEmpty()) return false;

            // turn into regex pattern, and match the whole string with ^$
            var regexPattern = &quot;^&quot; + Regex.Escape(wildcardPattern) + &quot;$&quot;;

            // add support for ?, #, *, [], and [!]
            regexPattern = regexPattern.Replace(@&quot;\[!&quot;, &quot;[^&quot;)
                                       .Replace(@&quot;\[&quot;, &quot;[&quot;)
                                       .Replace(@&quot;\]&quot;, &quot;]&quot;)
                                       .Replace(@&quot;\?&quot;, &quot;.&quot;)
                                       .Replace(@&quot;\*&quot;, &quot;.*&quot;)
                                       .Replace(@&quot;\#&quot;, @&quot;\d&quot;);

            var result = false;
            try
            {
                result = Regex.IsMatch(text, regexPattern);
            }
            catch (ArgumentException ex)
            {
                throw new ArgumentException(string.Format(&quot;Invalid pattern: {0}&quot;, wildcardPattern), ex);
            }
            return result;
        }

        /// &lt;summary&gt;Verifies simple email expressions. Doesn&#39;t allow numbers in the domain name and doesn&#39;t allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn&#39;t handle multiple &amp;quot;.&amp;quot; in the domain.&lt;/summary&gt;
        /// &lt;param name=&quot;inputToTest&quot;&gt;The input that needs to be tested.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsMaliciousCode(string inputToTest)
        {
            // Source: http://regexlib.com/RETester.aspx?regexp_id=977
            var regex =
                new Regex(
                    @&quot;(script)|(&lt;)|(&gt;)|(%3c)|(%3e)|(SELECT)|(UPDATE)|(INSERT)|(DELETE)|(GRANT)|(REVOKE)| (&amp;lt;) |(&amp;gt;)&quot;,
                    RegexOptions.IgnoreCase);
            var match = regex.Match(inputToTest);
            return match.Success;
        }

        /// &lt;summary&gt;Verifies simple email expressions. Doesn&#39;t allow numbers in the domain name and doesn&#39;t allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn&#39;t handle multiple &amp;quot;.&amp;quot; in the domain.&lt;/summary&gt;
        /// &lt;param name=&quot;eMailAddress&quot;&gt;The email address.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsValid_eMail(string eMailAddress)
        {
            // Source: http://regexlib.com/DisplayPatterns.aspx?cattabindex=0&amp;categoryId=1
            var regex = new Regex(@&quot;(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})&quot;);
            var match = regex.Match(eMailAddress);
            return match.Success;
        }

        /// &lt;summary&gt;Verifies the format of IP Addresses.&lt;/summary&gt;
        /// &lt;param name=&quot;ipAddress&quot;&gt;The IP address.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsValid_IP(string ipAddress)
        {
            // Source: http://regexlib.com/DisplayPatterns.aspx?cattabindex=1&amp;categoryId=2
            var regex =
                new Regex(
                    @&quot;^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$&quot;);
            var match = regex.Match(ipAddress);
            return match.Success;
        }
        /// &lt;summary&gt;Test for valid Url. whether they had HTTP in front or not. This will find those that don&#39;t have hyphens anywhere in them (except for after the domain)&lt;/summary&gt;
        /// &lt;param name=&quot;URL&quot;&gt;The in URL.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsValid_Url(string URL)
        {
            // Source: http://regexlib.com/DisplayPatterns.aspx?cattabindex=1&amp;categoryId=2
            var regex =
                new Regex(
                    @&quot;^(?&lt;link&gt;((?&lt;prot&gt;http:\/\/)*(?&lt;subdomain&gt;(www|[^\-\n]*)*)(\.)*(?&lt;domain&gt;[^\-\n]+)\.(?&lt;after&gt;[a-zA-Z]{2,3}[^&gt;\n]*)))$&quot;);
            var match = regex.Match(URL);
            return match.Success;
        }

        /// &lt;summary&gt;Verifies URLs. Checks for the leading protocol, a good looking domain (two or three letter TLD; no invalid characters in domain) and a somwhat reasonable file path.&lt;/summary&gt;
        /// &lt;param name=&quot;httpURL&quot;&gt;The HTTP address.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsValid_UrlHttp(string httpURL)
        {
            if (IsValid_Url(httpURL) == false) return false;

            // Source: http://regexlib.com/DisplayPatterns.aspx?cattabindex=1&amp;categoryId=2
            var regex = new Regex(@&quot;^http\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(/\S*)?$&quot;);
            var match = regex.Match(httpURL);
            return match.Success;
        }

        /// &lt;summary&gt;Determines whether [is valid_ regex] [the specified _regex pattern].&lt;/summary&gt;
        /// &lt;param name=&quot;_regexPattern&quot;&gt;The _regex pattern.&lt;/param&gt;
        /// &lt;param name=&quot;errorMsg&quot;&gt;The error MSG.&lt;/param&gt;
        /// &lt;param name=&quot;_regexOptions&quot;&gt;The _regex options.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsValid_Regex(string _regexPattern, out string errorMsg, RegexOptions _regexOptions = RegexOptions.None)
        {
            try
            {
                var _regex = new Regex(_regexPattern, _regexOptions);
            }
            catch (Exception ex)
            {
                errorMsg = &quot;Regex Error! &quot; +ex.Message;
                return false;
            }
            errorMsg = &quot;&quot;;
            return true;
        }

        /// &lt;summary&gt;Replaces the input string between the start marker and end marker with the replace string.&lt;/summary&gt;
        /// &lt;param name=&quot;marker_start&quot;&gt;The start marker&lt;/param&gt;
        /// &lt;param name=&quot;marker_end&quot;&gt;The end marker&lt;/param&gt;
        /// &lt;param name=&quot;inputStr&quot;&gt;The input string&lt;/param&gt;
        /// &lt;param name=&quot;replaceStr&quot;&gt;The replace string&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        [Pure]
        public string Replace_Between(string marker_start, string marker_end, string inputStr, string replaceStr)
        {
            marker_start = Replace_Between_Makers(marker_start);
            marker_end = Replace_Between_Makers(marker_end);
            var searchPattern = &quot;(&lt;marker_start&gt;)(.*?)(&lt;marker_end&gt;)&quot;.Replace(&quot;&lt;marker_start&gt;&quot;, marker_start).Replace(&quot;&lt;marker_end&gt;&quot;, marker_end);

            var regex = new Regex(searchPattern);
            var result = regex.Replace(inputStr, &quot;$1&quot; + replaceStr + &quot;$3&quot;);
            return result;
        }

        /// &lt;summary&gt;Converts the start marker into save string.&lt;/summary&gt;
        /// &lt;param name=&quot;marker_start&quot;&gt;The start marker&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        [Pure]
        private string Replace_Between_Makers(string marker_start)
        {
            var result = marker_start.Replace(&quot;[&quot;, &quot;\\[&quot;).Replace(&quot;]&quot;, &quot;\\]&quot;);
            return result;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[22,9,22,10,1],[23,13,23,49,1],[24,13,24,47,1],[25,13,25,35,1],[26,9,26,10,1],[38,9,38,10,1],[39,13,39,39,1],[39,40,39,53,1],[40,13,40,50,1],[40,51,40,64,1],[43,13,43,74,1],[46,13,51,63,1],[53,13,53,32,1],[55,13,55,14,1],[56,17,56,60,1],[57,13,57,14,1],[58,13,58,41,1],[59,13,59,14,1],[60,17,60,105,1],[62,13,62,27,1],[63,9,63,10,1],[69,9,69,10,1],[71,13,74,46,1],[75,13,75,50,1],[76,13,76,34,1],[77,9,77,10,1],[83,9,83,10,1],[85,13,85,76,1],[86,13,86,51,1],[87,13,87,34,1],[88,9,88,10,1],[94,9,94,10,1],[96,13,98,282,1],[99,13,99,48,1],[100,13,100,34,1],[101,9,101,10,1],[106,9,106,10,1],[108,13,110,143,1],[111,13,111,42,1],[112,13,112,34,1],[113,9,113,10,1],[119,9,119,10,1],[120,13,120,47,1],[120,48,120,61,1],[123,13,123,88,1],[124,13,124,46,1],[125,13,125,34,1],[126,9,126,10,1],[134,9,134,10,1],[136,13,136,14,1],[137,17,137,70,1],[138,13,138,14,1],[139,13,139,33,1],[140,13,140,14,1],[141,17,141,56,1],[142,17,142,30,1],[144,13,144,27,1],[145,13,145,25,1],[146,9,146,10,1],[156,9,156,10,1],[157,13,157,65,1],[158,13,158,61,1],[159,13,159,147,1],[161,13,161,50,1],[162,13,162,76,1],[163,13,163,27,1],[164,9,164,10,1],[171,9,171,10,1],[172,13,172,79,1],[173,13,173,27,1],[174,9,174,10,1]]);
    </script>
  </body>
</html>