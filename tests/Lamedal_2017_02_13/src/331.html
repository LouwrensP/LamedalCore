<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\lib\io\io_folder.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using JetBrains.Annotations;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.zz;

namespace LamedalCore.lib.IO
{
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action, GroupName = &quot;Folder&quot;)]
    public sealed class IO_Folder
    {
        private readonly IO_ _io = LamedalCore_.Instance.lib.IO;
        //private Assembly assembly;

        /// &lt;summary&gt;
        /// Creates the path if it does not exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;path&quot;&gt;The path. #path/#&lt;/param&gt;
        public void Create(string path)
        {
            var folders = path.Split(&#39;\\&#39;);
            var pathTest = &quot;&quot;;
            foreach (var folder in folders)
            {
                if (pathTest != &quot;&quot;) pathTest += &#39;\\&#39;;
                pathTest += folder;
                if (!Exists(pathTest))
                {
                    Directory.CreateDirectory(pathTest);
                }
            }
        }

        /// &lt;summary&gt;
        /// Deletes an empty directory from a specified path.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;folder&quot;&gt;The name of the empty directory to remove. This directory must be writable and empty.&lt;/param&gt;
        /// &lt;param name=&quot;recursive&quot;&gt;if true delete sub-folders too&lt;/param&gt;
        /// &lt;exception cref=&quot;T:System.IO.IOException&quot;&gt;A file with the same name and location specified by &lt;paramref name=&quot;folder&quot; /&gt; exists.-or-The directory is the application&#39;s current working directory.-or-The directory specified by &lt;paramref name=&quot;folder&quot; /&gt; is not empty.-or-The directory is read-only or contains a read-only file.-or-The directory is being used by another process.-or-There is an open handle on the directory, and the operating system is Windows XP or earlier. This open handle can result from directories. For more information, see How to: Enumerate Directories and Files.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.UnauthorizedAccessException&quot;&gt;The caller does not have the required permission.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;&lt;paramref name=&quot;folder&quot; /&gt; is a zero-length string, contains only white space, or contains one or more invalid characters as defined by &lt;see cref=&quot;F:System.IO.Path.InvalidPathChars&quot; /&gt;.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;&lt;paramref name=&quot;folder&quot; /&gt; is null.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.IO.PathTooLongException&quot;&gt;The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters and file names must be less than 260 characters.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.IO.DirectoryNotFoundException&quot;&gt;&lt;paramref name=&quot;folder&quot; /&gt; does not exist or could not be found.-or-&lt;paramref name=&quot;folder&quot; /&gt; refers to a file instead of a directory.-or-The specified path is invalid (for example, it is on an unmapped drive).&lt;/exception&gt;
        public void Delete(string folder, bool recursive = false)
        {
            if (!Exists(folder)) return;

            Directory.Delete(folder, recursive);
        }

        /// &lt;summary&gt;
        /// Check if the specified folder Exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;folderOrFile&quot;&gt;The file or folder. #path/#&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if XXXX, &lt;c&gt;false&lt;/c&gt; otherwise.&lt;/returns&gt;
        [Pure]
        public bool Exists(string folderOrFile)
        {
            if (folderOrFile.zIsNullOrEmpty()) return false;
            string folder = _io.Parts.Folder(folderOrFile);
            var result = Directory.Exists(folder);
            return result;
        }

        /// &lt;summary&gt;
        /// Determines whether the specified local path is a folder.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;localPathOrFile&quot;&gt;The local path or file.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsFolder(string localPathOrFile)
        {
            var attr = _io.File.Attributes_Get(localPathOrFile);  // get the file attributes for file or directory
            return ((attr &amp; FileAttributes.Directory) == FileAttributes.Directory);  //detect whether its a directory or file
        }

        /// &lt;summary&gt;
        /// Moves a file or a directory and its contents to a new location.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sourceDirName&quot;&gt;The path of the file or directory to move.&lt;/param&gt;
        /// &lt;param name=&quot;destDirName&quot;&gt;The path to the new location for &lt;paramref name=&quot;sourceDirName&quot; /&gt;. If &lt;paramref name=&quot;sourceDirName&quot; /&gt; is a file, then &lt;paramref name=&quot;destDirName&quot; /&gt; must also be a file name.&lt;/param&gt;
        /// &lt;exception cref=&quot;T:System.IO.IOException&quot;&gt;An attempt was made to move a directory to a different volume. -or- &lt;paramref name=&quot;destDirName&quot; /&gt; already exists. -or- The &lt;paramref name=&quot;sourceDirName&quot; /&gt; and &lt;paramref name=&quot;destDirName&quot; /&gt; parameters refer to the same file or directory.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.UnauthorizedAccessException&quot;&gt;The caller does not have the required permission.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;&lt;paramref name=&quot;sourceDirName&quot; /&gt; or &lt;paramref name=&quot;destDirName&quot; /&gt; is a zero-length string, contains only white space, or contains one or more invalid characters as defined by &lt;see cref=&quot;F:System.IO.Path.InvalidPathChars&quot; /&gt;.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;&lt;paramref name=&quot;sourceDirName&quot; /&gt; or &lt;paramref name=&quot;destDirName&quot; /&gt; is null.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.IO.PathTooLongException&quot;&gt;The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters and file names must be less than 260 characters.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.IO.DirectoryNotFoundException&quot;&gt;The path specified by &lt;paramref name=&quot;sourceDirName&quot; /&gt; is invalid (for example, it is on an unmapped drive).&lt;/exception&gt;
        public void Move(string sourceDirName, string destDirName)
        {
            Directory.Move(sourceDirName, destDirName);
        }

        /// &lt;summary&gt;Returns the absolute path for the specified path string.&lt;/summary&gt;
        /// &lt;param name=&quot;baseFolder&quot;&gt;The file or directory for which to obtain absolute path information.&lt;/param&gt;
        /// &lt;param name=&quot;relativeFolder&quot;&gt;The relative folder.&lt;/param&gt;
        /// &lt;returns&gt;The fully qualified location of &lt;paramref name=&quot;baseFolder&quot; /&gt;, such as &quot;C:\MyFile.txt&quot;.&lt;/returns&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;&lt;paramref name=&quot;baseFolder&quot; /&gt; is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in &lt;see cref=&quot;M:System.IO.Path.GetInvalidPathChars&quot; /&gt;.-or- The system could not retrieve the absolute path.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.Security.SecurityException&quot;&gt;The caller does not have the required permissions.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;&lt;paramref name=&quot;baseFolder&quot; /&gt; is null.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.NotSupportedException&quot;&gt;&lt;paramref name=&quot;baseFolder&quot; /&gt; contains a colon (&quot;:&quot;) that is not part of a volume identifier (for example, &quot;c:\&quot;).&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.IO.PathTooLongException&quot;&gt;The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.&lt;/exception&gt;
        /// &lt;PermissionSet&gt;&lt;IPermission class=&quot;System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; version=&quot;1&quot; PathDiscovery=&quot;*AllFiles*&quot; /&gt;&lt;/PermissionSet&gt;
        [Pure]
        public string Path_Absolute(string baseFolder = &quot;c:/folder1/folder2/&quot;, string relativeFolder = &quot;../filename.txt&quot;)
        {
            var result = Path.GetFullPath(baseFolder + relativeFolder);
            return _io.Parts._Format2Slash(result);
        }

        /// &lt;summary&gt;
        /// Application folder
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string Path_Application()
        {
            string result = &quot;&quot;;
            var assembly = Assembly.GetEntryAssembly();
            if (assembly == null) result = Directory.GetCurrentDirectory() +&quot;/&quot;;   // This will give the folder for xunit tests
            else
            {
                string location = assembly.Location;
                result = Path.GetDirectoryName(location) + &quot;/&quot;;
            }
            return _io.Parts._Format2Slash(result);  // Change all &#39;\&#39; to &#39;/&#39;
        }

        /// &lt;summary&gt;
        /// Function to get assembly path.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The assembly name&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        [Pure]
        public string Path_Assembly(AssemblyName name)
        {
            var result = _io.File.FilePath_Assembly(name);
            return _io.Parts.Folder(result);
        }



        /// &lt;summary&gt;
        /// Returns the path of the current user&#39;s temporary folder.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The path to the temporary folder, ending with a backslash.&lt;/returns&gt;
        /// &lt;exception cref=&quot;T:System.Security.SecurityException&quot;&gt;The caller does not have the required permissions.&lt;/exception&gt;
        /// &lt;PermissionSet&gt;&lt;IPermission class=&quot;System.Security.Permissions.EnvironmentPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; version=&quot;1&quot; Unrestricted=&quot;true&quot; /&gt;&lt;/PermissionSet&gt;
        public string Path_Temporary()
        {
            return _io.Parts._Format2Slash(Path.GetTempPath());
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,37,30,54,0],[52,34,52,41,0],[125,13,125,14,0],[126,17,126,53,0],[127,17,127,64,0],[128,13,128,14,0],[25,9,25,10,1],[26,13,26,44,1],[27,13,27,31,1],[28,13,28,20,1],[28,36,28,43,1],[28,22,28,32,1],[29,13,29,14,1],[30,17,30,36,1],[31,17,31,36,1],[32,17,32,39,1],[33,17,33,18,1],[34,21,34,57,1],[35,17,35,18,1],[36,13,36,14,1],[28,33,28,35,1],[37,9,37,10,1],[51,9,51,10,1],[52,13,52,33,1],[54,13,54,49,1],[55,9,55,10,1],[64,9,64,10,1],[65,13,65,47,1],[65,48,65,61,1],[66,13,66,60,1],[67,13,67,51,1],[68,13,68,27,1],[69,9,69,10,1],[77,9,77,10,1],[78,13,78,65,1],[79,13,79,84,1],[80,9,80,10,1],[94,9,94,10,1],[95,13,95,56,1],[96,9,96,10,1],[110,9,110,10,1],[111,13,111,72,1],[112,13,112,52,1],[113,9,113,10,1],[120,9,120,10,1],[121,13,121,32,1],[122,13,122,56,1],[123,13,123,34,1],[123,35,123,81,1],[129,13,129,52,1],[130,9,130,10,1],[139,9,139,10,1],[140,13,140,59,1],[141,13,141,45,1],[142,9,142,10,1],[153,9,153,10,1],[154,13,154,64,1],[155,9,155,10,1],[17,9,17,65,1]]);
    </script>
  </body>
</html>