<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\lib\solutionnt\classnt\classntbody\methodnt\methodntheader\methodntheader_methods.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.Linq;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.lib.SolutionNT.ClassNT.ClassNTBody.MethodNT.MethodNTHeader.MethodNTHeader_Parameter;
using LamedalCore.zz;

namespace LamedalCore.lib.SolutionNT.ClassNT.ClassNTBody.MethodNT.MethodNTHeader
{
    [BlueprintRule_Class(enBlueprintClassNetworkType.Undefined)]
    public sealed class MethodNTHeader_Methods
    {
        /// &lt;summary&gt;
        /// Parses the method header.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sourceLines&quot;&gt;The source lines.&lt;/param&gt;
        /// &lt;param name=&quot;ii&quot;&gt;The ii.&lt;/param&gt;
        /// &lt;param name=&quot;methodName&quot;&gt;Name of the method.&lt;/param&gt;
        /// &lt;param name=&quot;scope&quot;&gt;The scope.&lt;/param&gt;
        /// &lt;param name=&quot;returnType&quot;&gt;Type of the return.&lt;/param&gt;
        /// &lt;param name=&quot;kind&quot;&gt;The kind.&lt;/param&gt;
        /// &lt;param name=&quot;specialty&quot;&gt;The specialty.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string Parse(List&lt;string&gt; sourceLines, ref int ii, out string methodName, out enCode_Scope scope,
            out string returnType, out enMethod_Kind kind, out enCode_Specialty specialty)
        {
            specialty = enCode_Specialty.IsNormal;
            kind = enMethod_Kind.IsFunction;
            string seek = &quot;(&quot;;
            string methodLines = sourceLines[ii].Trim();

            //var jj = 0;
            if (methodLines.Contains(&quot;!!&quot;))
            {
                //! Check if this is a property (as a quickfix -&gt;properties will end with &#39;!!&#39;)
                seek = &quot;!!&quot;;
                kind = enMethod_Kind.IsProperty;
                if (methodLines.Contains(&quot;!!+&quot;)) kind = enMethod_Kind.IsSetter;
            }
            else
            {
                while (methodLines.Contains(&quot;)&quot;) == false) methodLines += &quot; &quot; + sourceLines[++ii].Trim(); //! Get the full method header
            }

            if (methodLines.Contains(&quot;&lt;T&gt;&quot;)) specialty = enCode_Specialty.IsGeneric;

            //! Parse the string and get the properties
            string methodBuffer = methodLines;
            string pre = seek.zVar_Next(ref methodBuffer); // &quot;(&quot;
            string buffer = pre;

            string scopeStr = &quot;_&quot; + &quot; &quot;.zVar_Next(ref buffer);
            scope = scopeStr.zEnum_To_EnumValue&lt;enCode_Scope&gt;();

            returnType = &quot; &quot;.zVar_Next(ref buffer);
            if (returnType == &quot;static&quot;)
            {
                specialty = (specialty == enCode_Specialty.IsNormal) ? enCode_Specialty.IsStatic : specialty | enCode_Specialty.IsStatic;
                returnType = &quot; &quot;.zVar_Next(ref buffer); // This is a static method -&gt; do more work
            }

            if (returnType.Contains(&quot;&lt;&quot;) &amp;&amp; returnType.Contains(&quot;&gt;&quot;) == false)
            {
                returnType += &quot; &quot; + &quot;&gt;&quot;.zVar_Next(ref buffer) + &quot;&gt;&quot;;
            }

            methodName = buffer;
            if (methodName == &quot;&quot;)
            {
                //! Test for special case - this is constructor
                methodName = returnType;
                returnType = &quot;&quot;;
            }

            //! Set last properties
            methodName = methodName.Trim();
            if (methodName.Contains(&quot;&lt;&quot;)) methodName = methodName.zvar_Id(&quot;&lt;&quot;);

            if (returnType == &quot;void&quot;) kind = enMethod_Kind.IsVoid;
            if (returnType.zIsNullOrEmpty()) kind = enMethod_Kind.IsConstructor;

            return methodLines;
        }

        public static List&lt;string&gt; Str2StrList(string methodHeader)
        {
            // This method is used internally by the unit testing code
            List&lt;string&gt; result = methodHeader.zConvert_Array_FromStr(&quot;&quot;.NL()).ToList();
            return result;
        }

        /// &lt;summary&gt;
        /// Generate method signature method from method name, parameters and return type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;methodName&quot;&gt;The method name&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;The parameters list&lt;/param&gt;
        /// &lt;param name=&quot;returnType&quot;&gt;The return type&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public static void ParameterSignature(string methodName, List&lt;MethodNTHeader_Parameter_&gt; parameters, string returnType, out string signature, out string parameterLine)
        {
            signature = &quot;&quot;;
            parameterLine = &quot;&quot;;
            var ref1 = &quot;&quot;;
            foreach (MethodNTHeader_Parameter_ parameter in parameters)
            {
                if (signature.Length &gt; 0)
                {
                    signature += &quot;,&quot;;
                    parameterLine += &quot;,&quot;;
                }
                switch (parameter.ParameterRefType)
                {
                    case enParameterRefType.ByReference: ref1 = &quot; ref &quot;; break;
                    case enParameterRefType.Output: ref1 = &quot; out &quot;; break;
                    case enParameterRefType.ParamArray: ref1 = &quot; params &quot;; break;
                }
                signature += ref1 + parameter.ParameterTypeName;
                parameterLine += ref1 + parameter.ParameterTypeName + &quot; &quot; + parameter.ParameterName;
            }
            signature = methodName + &quot;(&quot; + signature + &quot;)&quot;;
            if (returnType != &quot;void&quot;) signature += &quot; : &quot; + returnType;

        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[114,53,114,68,0],[114,69,114,75,0],[26,9,26,10,1],[27,13,27,51,1],[28,13,28,45,1],[29,13,29,31,1],[30,13,30,57,1],[33,13,33,44,1],[34,13,34,14,1],[36,17,36,29,1],[37,17,37,49,1],[38,17,38,49,1],[38,50,38,80,1],[39,13,39,14,1],[41,13,41,14,1],[42,60,42,106,1],[42,17,42,59,1],[43,13,43,14,1],[45,13,45,45,1],[45,46,45,85,1],[48,13,48,47,1],[49,13,49,59,1],[50,13,50,33,1],[52,13,52,63,1],[53,13,53,65,1],[55,13,55,52,1],[56,13,56,40,1],[57,13,57,14,1],[58,17,58,138,1],[59,17,59,56,1],[60,13,60,14,1],[62,13,62,79,1],[63,13,63,14,1],[64,17,64,69,1],[65,13,65,14,1],[67,13,67,33,1],[68,13,68,34,1],[69,13,69,14,1],[71,17,71,41,1],[72,17,72,33,1],[73,13,73,14,1],[76,13,76,44,1],[77,13,77,42,1],[77,43,77,80,1],[79,13,79,38,1],[79,39,79,67,1],[80,13,80,45,1],[80,46,80,81,1],[82,13,82,32,1],[83,9,83,10,1],[86,9,86,10,1],[88,13,88,89,1],[89,13,89,27,1],[90,9,90,10,1],[100,9,100,10,1],[101,13,101,28,1],[102,13,102,32,1],[103,13,103,27,1],[104,13,104,20,1],[104,61,104,71,1],[104,22,104,57,1],[105,13,105,14,1],[106,17,106,42,1],[107,17,107,18,1],[108,21,108,38,1],[109,21,109,42,1],[110,17,110,18,1],[111,17,111,52,1],[113,58,113,73,1],[113,74,113,80,1],[115,57,115,75,1],[115,76,115,82,1],[117,17,117,65,1],[118,17,118,101,1],[119,13,119,14,1],[104,58,104,60,1],[120,13,120,60,1],[121,13,121,38,1],[121,39,121,71,1],[123,9,123,10,1]]);
    </script>
  </body>
</html>