<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\lib\solutionnt\classnt\classntbody\methodnt\methodntcomment\methodntcomment_methods.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.lib.SolutionNT.ClassNT.ClassNTAttributes;
using LamedalCore.lib.SolutionNT.ClassNT.ClassNTStats;
using LamedalCore.zz;

namespace LamedalCore.lib.SolutionNT.ClassNT.ClassNTBody.MethodNT.MethodNTComment
{
    [BlueprintRule_Class(enBlueprintClassNetworkType.VS_Static)]
    public static class MethodNTComment_Methods
    {
        /// &lt;summary&gt;
        /// Get the documentation return string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;documentationReturnLine&quot;&gt;The documentation return line&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public static string Return_FromXML(string documentationReturnLine)
        {
            return documentationReturnLine.zConvert_XML_ValueBetweenTags(&quot;returns&quot;);
        }
        
        /// &lt;summary&gt;
        /// Create string from setup XML return definition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;returnHelpStr&quot;&gt;The return help string.&lt;/param&gt;
        /// &lt;param name=&quot;convertToValidXML&quot;&gt;The convert to validentifier XML.&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public static string Return_ToXML(string returnHelpStr, bool convertToValidXML = false)
        {
            if (convertToValidXML) returnHelpStr = LamedalCore_.Instance.lib.XML.Setup.Fix_InvalidXML(returnHelpStr);
            returnHelpStr = ClassNT_Methods.codeSpace + &quot;&lt;returns&gt;&quot; + returnHelpStr + &quot;&lt;/returns&gt;&quot;;
            return returnHelpStr;
        }

        /// &lt;summary&gt;
        /// Function to get the comment from XML 
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;XML&quot;&gt;The XML&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public static string Summary_FromXML(string XML)
        {
            return LamedalCore_.Instance.lib.XML.Setup.XML_ValueBetweenTags(XML, &quot;summary&quot;).Replace(&quot;///&quot;, &quot;&quot;).Trim();
        }

        /// &lt;summary&gt;Create string from setup XML summary definition.&lt;/summary&gt;
        /// &lt;param name=&quot;summaryStr&quot;&gt;The summary string.&lt;/param&gt;
        /// &lt;param name=&quot;convertToValidXML&quot;&gt;The convert to validentifier XML.&lt;/param&gt;
        /// &lt;param name=&quot;Add3Slashes&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [add3 slashes].&lt;/param&gt;
        /// &lt;returns&gt;string&lt;/returns&gt;
        public static string Summary_ToXML(string summaryStr, bool convertToValidXML = false, bool Add3Slashes = false)
        {
            var space = ClassNT_Methods.codeSpace;
            if (Add3Slashes) space += &quot;/// &quot;;
            if (convertToValidXML) summaryStr = LamedalCore_.Instance.lib.XML.Setup.Fix_InvalidXML(summaryStr);
            var summaryXML = space + &quot;&lt;summary&gt;&quot; + summaryStr + &quot;&lt;/summary&gt;&quot;.NL();    // Do not add newline here
            return summaryXML;
        }

        #region Comment_Parts

        /// &lt;summary&gt;
        /// Converts the method&#39;s documentation to intermediate lines list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sourceLines&quot;&gt;The header lines list&lt;/param&gt;
        /// &lt;param name=&quot;ii&quot;&gt;The ii indexer reference variable&lt;/param&gt;
        /// &lt;param name=&quot;summaryLine&quot;&gt;The summary line.&lt;/param&gt;
        /// &lt;param name=&quot;parameterLines&quot;&gt;The documentation lines.&lt;/param&gt;
        /// &lt;param name=&quot;attributeLines&quot;&gt;The attribute lines.&lt;/param&gt;
        /// &lt;param name=&quot;returnLine&quot;&gt;The return line.&lt;/param&gt;
        /// &lt;param name=&quot;ctiCodeLine&quot;&gt;The cti code line.&lt;/param&gt;
        public static void Comment_Parts(List&lt;string&gt; sourceLines, ref int ii, out string summaryLine, out List&lt;string&gt; parameterLines, out List&lt;string&gt; attributeLines, out string returnLine, out string ctiCodeLine)
        {
            // &lt;summary&gt;Determines whether the specified input string contains index. This is supposed to be faster than IndexOf()&lt;/summary&gt;
            bool summaryStart = false;
            bool returnStart = false;
            bool codeStart = false;
            parameterLines = new List&lt;string&gt;();
            attributeLines = new List&lt;string&gt;();
            returnLine = &quot;&quot;;
            summaryLine = &quot;&quot;;
            ctiCodeLine = &quot;&quot;;

            string line = sourceLines[ii].Trim();
            while (line == &quot;&quot; || line.Contains(&quot;///&quot;) || line.Substring(0, 1) == &quot;[&quot;)
            {
                if (line.Substring(0, 1) == &quot;[&quot;)
                {
                    // Attributes
                    attributeLines.AddRange(Source_ParseAttributeLine(line));
                }
                else if (line.Contains(&quot;////&quot;) == false &amp;&amp; line != &quot;&quot;)
                {
                    // This is not a comment or this is an empty line -&gt; This is the documentation
                    line = line.Replace(&quot;///&quot;, &quot;&quot;).Trim();

                    #region Summary =======================================================
                    if (summaryStart)
                    {
                        if (summaryLine != &quot;&lt;summary&gt;&quot;) summaryLine += &quot; &quot;;
                        summaryLine += line;
                        if (line.Contains(&quot;&lt;/summary&gt;&quot;))
                        {
                            summaryStart = false;
                            line = summaryLine;
                        }
                    }
                    else if (line.Contains(&quot;&lt;summary&gt;&quot;))
                    {
                        summaryLine = line;
                        if (line.Contains(&quot;&lt;/summary&gt;&quot;) == false) summaryStart = true;
                    }
                    #endregion

                    #region Return ======================================================
                    if (returnStart)
                    {
                        if (returnLine != &quot;&lt;returns&gt;&quot;) returnLine += &quot; &quot;;
                        returnLine += line;
                        if (line.Contains(&quot;&lt;/returns&gt;&quot;))
                        {
                            returnStart = false;
                            line = returnLine;
                        }
                    }
                    else if (line.Contains(&quot;&lt;returns&gt;&quot;))
                    {
                        returnLine = line;
                        if (line.Contains(&quot;&lt;/returns&gt;&quot;) == false) returnStart = true;
                    }
                    #endregion ==============================================================

                    #region Code ======================================================
                    if (codeStart)
                    {
                        ctiCodeLine += line;
                        if (ctiCodeLine.Contains(&quot;&lt;/code&gt;&quot;))
                        {
                            codeStart = false;
                            line = ctiCodeLine;
                        }
                    }
                    else if (line.Contains(&quot;&lt;code&gt;&quot;))
                    {
                        ctiCodeLine = line;
                        if (line.Contains(&quot;&lt;/code&gt;&quot;) == false) codeStart = true;
                    }
                    #endregion ==============================================================

                    // Only add the line if we know what the return value is -&gt; we want to compress the XML to viewer lines as it is then more readable
                    if (summaryStart == false &amp;&amp; returnStart == false)
                    {
                        if (line.Contains(&quot;&lt;param name&quot;)) parameterLines.Add(line);
                    }
                }

                ii++;
                line = sourceLines[ii].Trim(); // Move to the next line
            }

            summaryLine = summaryLine.zConvert_XML_ValueBetweenTags(&quot;summary&quot;).Trim();
            returnLine = returnLine.zConvert_XML_ValueBetweenTags(&quot;returns&quot;).Trim();
            ctiCodeLine = ctiCodeLine.zConvert_XML_ValueBetweenTags(&quot;code&quot;).Trim();
        }

        private static List&lt;string&gt; Source_ParseAttributeLine(string line)
        {
            // Is there more than one attribute in the same line -&gt; split the lines
            List&lt;string&gt; attributes = line.zConvert_Str_ToListStr(&quot;, &quot;);
            if (attributes.Count &gt; 1)
            {
                for (int ii = 0; ii &lt; attributes.Count; ii++)
                {
                    if (ii &gt; 0) attributes[ii] = &quot;[&quot; + attributes[ii];
                    if (ii &lt; attributes.Count - 1) attributes[ii] = attributes[ii] + &quot;]&quot;;
                }
            }
            return attributes;
        }

        #endregion

        /// &lt;summary&gt;
        /// Converts the method&#39;s documentation to intermediate lines list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sourceLines&quot;&gt;The header lines list&lt;/param&gt;
        /// &lt;param name=&quot;ii&quot;&gt;The ii indexer reference variable&lt;/param&gt;
        /// &lt;param name=&quot;statistics&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;commentLines&quot;&gt;The documentation lines.&lt;/param&gt;
        /// &lt;param name=&quot;summaryLine&quot;&gt;The summary line.&lt;/param&gt;
        /// &lt;param name=&quot;attributeLines&quot;&gt;The attribute lines.&lt;/param&gt;
        /// &lt;param name=&quot;returnLine&quot;&gt;The return line.&lt;/param&gt;
        /// &lt;param name=&quot;ctiCodeLine&quot;&gt;The cti code line.&lt;/param&gt;
        public static void Documentation_Parts(List&lt;string&gt; sourceLines, ref int ii, ClassNTStats_ statistics, out List&lt;string&gt; commentLines, out string summaryLine, 
                    out List&lt;string&gt; attributeLines, out string returnLine, out string ctiCodeLine)
        {
            // &lt;summary&gt;Determines whether the specified input string contains index. This is supposed to be faster than IndexOf()&lt;/summary&gt;
            bool summaryStart = false;
            bool returnStart = false;
            //bool codeStart = false;
            commentLines = new List&lt;string&gt;();
            attributeLines = new List&lt;string&gt;();
            returnLine = &quot;&quot;;
            summaryLine = &quot;&quot;;
            ctiCodeLine = &quot;&quot;;

            string line = sourceLines[ii].Trim();
            while (line == &quot;&quot; || line.Contains(&quot;///&quot;) || line.Substring(0, 1) == &quot;[&quot;)
            {
                statistics.ClassTotalLines++;
                if (line.Substring(0, 1) == &quot;[&quot;)
                {
                    // Attributes
                    attributeLines.AddRange(ClassNTAttributes_Methods.Attributes_FromCodeLine(line));
                    statistics.TotalAttributes++;
                    statistics.ClassTotalCodeLines++;
                }
                else if (line.Contains(&quot;////&quot;) == false &amp;&amp; line != &quot;&quot;)
                {
                    // This is not a comment or this is an empty line -&gt; This is the documentation
                    statistics.ClassTotalCommentLines++;
                    line = line.Replace(&quot;///&quot;, &quot;&quot;).Trim();

                    #region Summary =======================================================
                    if (summaryStart)
                    {
                        summaryLine += line;
                        if (line.Contains(&quot;&lt;/summary&gt;&quot;))
                        {
                            summaryStart = false;
                            line = summaryLine;
                        }
                    }
                    else if (line.Contains(&quot;&lt;summary&gt;&quot;))
                    {
                        summaryLine = line;
                        if (line.Contains(&quot;&lt;/summary&gt;&quot;) == false) summaryStart = true;
                    }
                    #endregion

                    #region Return ======================================================
                    if (returnStart)
                    {
                        returnLine += line;
                        if (line.Contains(&quot;&lt;/returns&gt;&quot;))
                        {
                            returnStart = false;
                            line = returnLine;
                        }
                    }
                    else if (line.Contains(&quot;&lt;returns&gt;&quot;))
                    {
                        returnLine = line;
                        if (line.Contains(&quot;&lt;/returns&gt;&quot;) == false) returnStart = true;
                    }
                    #endregion ==============================================================

                    #region Code ======================================================
                    // Code tag is no longer used
                    //if (codeStart)
                    //{
                    //    ctiCodeLine += line;
                    //    if (ctiCodeLine.Contains(&quot;&lt;/code&gt;&quot;))
                    //    {
                    //        codeStart = false;
                    //        line = ctiCodeLine;
                    //    }
                    //}
                    //else 
                    //if (line.Contains(&quot;&lt;code &quot;))
                    //{
                    //    ctiCodeLine = line;
                    //    if (line.Contains(&quot;&lt;/code&gt;&quot;) == false) codeStart = true;
                    //}
                    #endregion ==============================================================

                    // Only add the line if we know what the return value is -&gt; we want to compress the XML to viewer lines as it is then more readable
                    if (summaryStart == false &amp;&amp; returnStart == false) commentLines.Add(line);
                }

                ii++;
                line = sourceLines[ii].Trim(); // Move to the next line
            }

            summaryLine = summaryLine.zConvert_XML_ValueBetweenTags(&quot;summary&quot;);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[19,9,19,10,1],[20,13,20,85,1],[21,9,21,10,1],[30,9,30,10,1],[31,13,31,35,1],[31,36,31,118,1],[32,13,32,100,1],[33,13,33,34,1],[34,9,34,10,1],[42,9,42,10,1],[43,13,43,119,1],[44,9,44,10,1],[52,9,52,10,1],[53,13,53,51,1],[54,13,54,29,1],[54,30,54,46,1],[55,13,55,35,1],[55,36,55,112,1],[56,13,56,83,1],[57,13,57,31,1],[58,9,58,10,1],[73,9,73,10,1],[75,13,75,39,1],[76,13,76,38,1],[77,13,77,36,1],[78,13,78,49,1],[79,13,79,49,1],[80,13,80,29,1],[81,13,81,30,1],[82,13,82,30,1],[84,13,84,50,1],[86,13,86,14,1],[87,17,87,49,1],[88,17,88,18,1],[90,21,90,78,1],[91,17,91,18,1],[92,22,92,71,1],[93,17,93,18,1],[95,21,95,59,1],[98,21,98,38,1],[99,21,99,22,1],[100,25,100,56,1],[100,57,100,76,1],[101,25,101,45,1],[102,25,102,57,1],[103,25,103,26,1],[104,29,104,50,1],[105,29,105,48,1],[106,25,106,26,1],[107,21,107,22,1],[108,26,108,57,1],[109,21,109,22,1],[110,25,110,44,1],[111,25,111,66,1],[111,67,111,87,1],[112,21,112,22,1],[116,21,116,37,1],[117,21,117,22,1],[118,25,118,55,1],[118,56,118,74,1],[119,25,119,44,1],[120,25,120,57,1],[121,25,121,26,1],[122,29,122,49,1],[123,29,123,47,1],[124,25,124,26,1],[125,21,125,22,1],[126,26,126,57,1],[127,21,127,22,1],[128,25,128,43,1],[129,25,129,66,1],[129,67,129,86,1],[130,21,130,22,1],[134,21,134,35,1],[135,21,135,22,1],[136,25,136,45,1],[137,25,137,61,1],[138,25,138,26,1],[139,29,139,47,1],[140,29,140,48,1],[141,25,141,26,1],[142,21,142,22,1],[143,26,143,54,1],[144,21,144,22,1],[145,25,145,44,1],[146,25,146,63,1],[146,64,146,81,1],[147,21,147,22,1],[151,21,151,71,1],[152,21,152,22,1],[153,25,153,58,1],[153,59,153,84,1],[154,21,154,22,1],[155,17,155,18,1],[157,17,157,22,1],[158,17,158,47,1],[159,13,159,14,1],[85,13,85,86,1],[161,13,161,87,1],[162,13,162,85,1],[163,13,163,84,1],[164,9,164,10,1],[167,9,167,10,1],[169,13,169,73,1],[170,13,170,38,1],[171,13,171,14,1],[172,22,172,32,1],[173,17,173,18,1],[174,21,174,32,1],[174,33,174,71,1],[175,21,175,51,1],[175,52,175,90,1],[176,17,176,18,1],[172,57,172,61,1],[172,34,172,55,1],[177,13,177,14,1],[178,13,178,31,1],[179,9,179,10,1],[196,9,196,10,1],[198,13,198,39,1],[199,13,199,38,1],[201,13,201,47,1],[202,13,202,49,1],[203,13,203,29,1],[204,13,204,30,1],[205,13,205,30,1],[207,13,207,50,1],[209,13,209,14,1],[210,17,210,46,1],[211,17,211,49,1],[212,17,212,18,1],[214,21,214,102,1],[215,21,215,50,1],[216,21,216,54,1],[217,17,217,18,1],[218,22,218,71,1],[219,17,219,18,1],[221,21,221,57,1],[222,21,222,59,1],[225,21,225,38,1],[226,21,226,22,1],[227,25,227,45,1],[228,25,228,57,1],[229,25,229,26,1],[230,29,230,50,1],[231,29,231,48,1],[232,25,232,26,1],[233,21,233,22,1],[234,26,234,57,1],[235,21,235,22,1],[236,25,236,44,1],[237,25,237,66,1],[237,67,237,87,1],[238,21,238,22,1],[242,21,242,37,1],[243,21,243,22,1],[244,25,244,44,1],[245,25,245,57,1],[246,25,246,26,1],[247,29,247,49,1],[248,29,248,47,1],[249,25,249,26,1],[250,21,250,22,1],[251,26,251,57,1],[252,21,252,22,1],[253,25,253,43,1],[254,25,254,66,1],[254,67,254,86,1],[255,21,255,22,1],[278,21,278,71,1],[278,72,278,95,1],[279,17,279,18,1],[281,17,281,22,1],[282,17,282,47,1],[283,13,283,14,1],[208,13,208,86,1],[285,13,285,80,1],[286,9,286,10,1]]);
    </script>
  </body>
</html>