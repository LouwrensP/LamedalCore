<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\types\types_dictionary.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml.Linq;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;

namespace LamedalCore.Types
{
    /// &lt;summary&gt;
    /// 
    /// &lt;/summary&gt;
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action)]
    public sealed class Types_Dictionary
    {
        ///// &lt;summary&gt;
        ///// Returns the value associated with the specified key if there
        ///// already is one, or inserts the specified value and returns it.
        ///// &lt;/summary&gt;
        ///// &lt;typeparam name=&quot;TKey&quot;&gt;Type of key&lt;/typeparam&gt;
        ///// &lt;typeparam name=&quot;TValue&quot;&gt;Type of value&lt;/typeparam&gt;
        ///// &lt;param name=&quot;dictionary&quot;&gt;Dictionary to access&lt;/param&gt;
        ///// &lt;param name=&quot;key&quot;&gt;Key to lookup&lt;/param&gt;
        ///// &lt;param name=&quot;missingValue&quot;&gt;Value to use when key is missing&lt;/param&gt;
        ///// &lt;returns&gt;Existing value in the dictionary, or new one inserted&lt;/returns&gt;
        //public TValue Key_GetOrCreate&lt;TKey, TValue&gt;(IDictionary&lt;TKey, TValue&gt; dictionary, TKey key, TValue missingValue)
        //{
        //    TValue result;
        //    if (dictionary.TryGetValue(key, out result) == false)
        //    {
        //        result = missingValue;
        //        dictionary[key] = result;
        //    }
        //    return result;
        //}

        /// &lt;summary&gt;
        /// Returns the value associated with the specified key if there
        /// already is one, or inserts the specified value and returns it.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;Type of key&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;Type of value&lt;/typeparam&gt;
        /// &lt;param name=&quot;dictionary&quot;&gt;Dictionary to access&lt;/param&gt;
        /// &lt;param name=&quot;key&quot;&gt;Key to lookup&lt;/param&gt;
        /// &lt;param name=&quot;newValue&quot;&gt;Value to use when key is missing&lt;/param&gt;
        /// &lt;param name=&quot;onError&quot;&gt;The on error.&lt;/param&gt;
        public void Key_AddSafe&lt;TKey, TValue&gt;(IDictionary&lt;TKey, TValue&gt; dictionary, TKey key, TValue newValue, 
                    enDuplicateError onError = enDuplicateError.Ignore)
        {
            TValue result;
            if (dictionary.TryGetValue(key, out result) == true)
            {
                switch (onError)
                {
                    case enDuplicateError.Replace: dictionary[key] = newValue; return; // &lt;============================
                    case enDuplicateError.Ignore: return;
                    case enDuplicateError.Error: throw new ArgumentException(&quot;newValue&quot;);
                }
            }
            dictionary.Add(key, newValue);
        }

        /// &lt;summary&gt;
        /// Return the keys and values of the dictionary.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dictionary&quot;&gt;The dictionary dictionary&lt;/param&gt;
        /// &lt;param name=&quot;keys&quot;&gt;Return the keys list&lt;/param&gt;
        /// &lt;param name=&quot;values&quot;&gt;Return the values list&lt;/param&gt;
        public void KeysAndValues&lt;TKey, TValue&gt;(IDictionary&lt;TKey, TValue&gt; dictionary, out List&lt;TKey&gt; keys, out List&lt;TValue&gt; values)
        {
            keys = dictionary.Keys.ToList();
            values = dictionary.Values.ToList();
        }

        /// &lt;summary&gt;Sorts the dictionary on values.&lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the key.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the value.&lt;/typeparam&gt;
        /// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
        /// &lt;param name=&quot;ascending&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [ascending].&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IOrderedEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; SortOnValue&lt;TKey, TValue&gt;(IDictionary&lt;TKey, TValue&gt; dictionary, bool ascending = true)
        {
            IOrderedEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; result;
            if (ascending)
                result = from entry in dictionary orderby entry.Value ascending select entry;
            else result = from entry in dictionary orderby entry.Value descending select entry;

            return result;
        }

        /// &lt;summary&gt;Create a Dictionary that ignore the case of the key.&lt;/summary&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the value.&lt;/typeparam&gt;
        /// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IDictionary&lt;string, TValue&gt; Create_IgnoreCase&lt;TValue&gt;(IDictionary&lt;string, TValue&gt; dictionary = null)
        {
            if (dictionary == null) return new Dictionary&lt;string, TValue&gt;(StringComparer.OrdinalIgnoreCase);

            return new Dictionary&lt;string, TValue&gt;(dictionary, StringComparer.OrdinalIgnoreCase);
        }

        // Returns a new dictionary of this ... others merged leftward.
        // Keeps the type of &#39;this&#39;, which must be default-instantiable.
        // Example: 
        //   result = map.MergeLeft(other1, other2, ...)
        public IDictionary&lt;K, V&gt; Merge&lt;K, V&gt;(IDictionary&lt;K, V&gt; me, params IDictionary&lt;K, V&gt;[] others)
        {
            var newMap = new Dictionary&lt;K, V&gt;();
            foreach (IDictionary&lt;K, V&gt; src in (new List&lt;IDictionary&lt;K, V&gt;&gt; { me }).Concat(others))
            {
                // ^-- echk. Not quite there type-system.
                foreach (KeyValuePair&lt;K, V&gt; p in src)
                {
                    newMap[p.Key] = p.Value;
                }
            }
            return newMap;
        }

        /// &lt;summary&gt;Convert object to dictionary.&lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Dictionary&lt;string, object&gt; Object_ToDictionary(object Object)
        {
            var dictionary = new Dictionary&lt;string, object&gt;();

            foreach (var propertyInfo in Object.GetType().GetTypeInfo().GetProperties())
            {
                if (propertyInfo.GetIndexParameters().Length == 0)
                {
                    dictionary.Add(propertyInfo.Name, propertyInfo.GetValue(Object, null));
                }
            }

            return dictionary;
        }

        /// &lt;summary&gt;Converts a string dictionary into XML.&lt;/summary&gt;
        /// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
        /// &lt;param name=&quot;replaceSpaceWith&quot;&gt;The replace space with.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string XML_FromDictionary(IDictionary&lt;string, string&gt; dictionary, string replaceSpaceWith = &quot;_&quot;)
        {
            XElement element = new XElement(&quot;root&quot;, dictionary.Select(x =&gt; new XElement(x.Key.Replace(&quot; &quot;, replaceSpaceWith), x.Value)));
            return element.ToString();
        }

        /// &lt;summary&gt;Converts XML to a string dictionary.&lt;/summary&gt;
        /// &lt;param name=&quot;xml&quot;&gt;The XML.&lt;/param&gt;
        /// &lt;param name=&quot;restoreSpaceFrom&quot;&gt;The restore space from.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IDictionary&lt;string, string&gt; XML_ToDictionary(string xml, string restoreSpaceFrom = &quot;_&quot;)
        {
            XElement rootElement = XElement.Parse(xml);
            var dictionary = new Dictionary&lt;string, string&gt;();
            foreach (var element in rootElement.Elements())
            {
                dictionary.Add(element.Name.LocalName.Replace(restoreSpaceFrom, &quot; &quot;), element.Value);
            }
            return dictionary;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[60,13,60,14,0],[50,9,50,10,1],[52,13,52,65,1],[53,13,53,14,1],[54,17,54,33,1],[56,52,56,79,1],[56,80,56,87,1],[57,51,57,58,1],[58,50,58,90,1],[61,13,61,43,1],[62,9,62,10,1],[71,9,71,10,1],[72,13,72,45,1],[73,13,73,49,1],[74,9,74,10,1],[83,9,83,10,1],[85,13,85,27,1],[86,17,86,59,1],[86,70,86,94,1],[87,18,87,60,1],[87,71,87,96,1],[89,13,89,27,1],[90,9,90,10,1],[97,9,97,10,1],[98,13,98,36,1],[98,37,98,109,1],[100,13,100,97,1],[101,9,101,10,1],[108,9,108,10,1],[109,13,109,49,1],[110,13,110,20,1],[110,47,110,98,1],[110,22,110,43,1],[111,13,111,14,1],[113,17,113,24,1],[113,50,113,53,1],[113,26,113,46,1],[114,17,114,18,1],[115,21,115,45,1],[116,17,116,18,1],[113,47,113,49,1],[117,13,117,14,1],[110,44,110,46,1],[118,13,118,27,1],[119,9,119,10,1],[125,9,125,10,1],[126,13,126,63,1],[128,13,128,20,1],[128,42,128,88,1],[128,22,128,38,1],[129,13,129,14,1],[130,17,130,67,1],[131,17,131,18,1],[132,21,132,92,1],[133,17,133,18,1],[134,13,134,14,1],[128,39,128,41,1],[136,13,136,31,1],[137,9,137,10,1],[144,9,144,10,1],[145,13,145,76,1],[145,135,145,138,1],[146,13,146,39,1],[147,9,147,10,1],[154,9,154,10,1],[155,13,155,56,1],[156,13,156,63,1],[157,13,157,20,1],[157,37,157,59,1],[157,22,157,33,1],[158,13,158,14,1],[159,17,159,102,1],[160,13,160,14,1],[157,34,157,36,1],[161,13,161,31,1],[162,9,162,10,1],[86,59,86,70,1],[87,60,87,71,1],[145,76,145,135,1]]);
    </script>
  </body>
</html>