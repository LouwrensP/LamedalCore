<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\dev\lamedal\trunk\lamedalcore\lamedalcore\types\types_object.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using JetBrains.Annotations;
using LamedalCore.domain.Attributes;
using LamedalCore.domain.Enumerals;
using LamedalCore.zz;

namespace LamedalCore.Types
{
    /// &lt;summary&gt;
    /// Is comparisons 
    /// private readonly Types_Is Is = Blueprint_.Instance.Types.Is;
    /// &lt;/summary&gt;
    /// &lt;code&gt;CTI;&lt;/code&gt;
    [BlueprintRule_Class(enBlueprintClassNetworkType.Node_Action)]
    public sealed class Types_Object
    {
        private readonly LamedalCore_ _lamed = LamedalCore_.Instance; // system library

        /// &lt;summary&gt;Test if a value is betweens the start and end values.&lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;actual&quot;&gt;The actual.&lt;/param&gt;
        /// &lt;param name=&quot;lower&quot;&gt;The lower.&lt;/param&gt;
        /// &lt;param name=&quot;upper&quot;&gt;The upper.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool Between&lt;T&gt;(T actual, T lower, T upper) where T : IComparable&lt;T&gt;
        {
            return actual.CompareTo(lower) &gt;= 0 &amp;&amp; actual.CompareTo(upper) &lt;= 0;
        }

        /// &lt;summary&gt;Cast object to T.&lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The objectect&lt;/param&gt;
        /// &lt;returns&gt;T&lt;/returns&gt;
        public T CastTo&lt;T&gt;(object Object)
        {
            return (T)Object;
        }

        /// &lt;summary&gt;Cast object to type.&lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The objectect&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;The type&lt;/param&gt;
        /// &lt;returns&gt;object&lt;/returns&gt;
        public object CastTo(object Object, Type type)
        {
            return Convert.ChangeType(Object, type);
        }

        /// &lt;summary&gt;Use default comparison between generic types.&lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;x&quot;&gt;The x.&lt;/param&gt;
        /// &lt;param name=&quot;y&quot;&gt;The y.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool Compare&lt;T&gt;(T x, T y)
        {
            return EqualityComparer&lt;T&gt;.Default.Equals(x, y);
        }

        /// &lt;summary&gt;Creates type T.&lt;/summary&gt;
        public T Create&lt;T&gt;(params object[] args)
        {
            return (T)Activator.CreateInstance(typeof(T), args);
        }

        /// &lt;summary&gt;
        /// Default value for the type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;t&quot;&gt;The type&lt;/param&gt;
        /// &lt;returns&gt;object&lt;/returns&gt;
        public object DefaultValue(Type t)
        {
            if (t.GetTypeInfo().IsValueType) return Activator.CreateInstance(t);

            return null;
        }

        /// &lt;summary&gt;
        /// Default value for the type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public T DefaultValue&lt;T&gt;()
        {
            return default(T);
        }

        /// &lt;summary&gt;
        /// Determines whether the value is part of a list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;val&quot;&gt;The value&lt;/param&gt;
        /// &lt;param name=&quot;values&quot;&gt;The values optional array&lt;/param&gt;
        /// &lt;returns&gt;bool&lt;/returns&gt;
        public bool In&lt;T&gt;(T val, params T[] values) where T : struct
        {
            return values.Contains(val);
        }

        /// &lt;summary&gt;Determines whether the specified object is a class.&lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsClass(object Object)
        {
            Type type = Object.GetType();
            TypeInfo typeInfo = type.GetTypeInfo();
            return typeInfo.IsClass;
        }

        /// &lt;summary&gt;
        /// Test if the object is a complex type like class, array, dictionary, list or struct.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsComplexType(object Object)
        {
            Type type = Object.GetType();
            TypeInfo typeInfo = type.GetTypeInfo();

            return !IsSimpleType(type)
                   &amp;&amp; (typeInfo.IsClass
                       || type.IsArray
                       || IsIDictionary(Object)
                       || IsIList(Object)
                       || IsStruct(Object)
                       );
        }

        /// &lt;summary&gt;
        /// Is the type a dictionary.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsIDictionary(object Object)
        {
            Type type = Object.GetType();
            var typeInfo = type.GetTypeInfo();
            return (typeof(IDictionary).GetTypeInfo().IsAssignableFrom(typeInfo));
        }

        /// &lt;summary&gt;Determines whether two objects are equal using Json serialisation.&lt;/summary&gt;
        /// &lt;param name=&quot;Object1&quot;&gt;The first object&lt;/param&gt;
        /// &lt;param name=&quot;Object2&quot;&gt;The second object&lt;/param&gt;
        /// &lt;param name=&quot;errorMsg&quot;&gt;The error message&lt;/param&gt;
        /// &lt;returns&gt;bool&lt;/returns&gt;
        public bool IsEqual(object Object1, object Object2, out string errorMsg)
        {
            return _lamed.lib.IO.Json.Object_IsEqual(Object1, Object2, out errorMsg);
        }

        /// &lt;summary&gt;
        /// Determines whether the type is IList .
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsIList(object Object)
        {
            var typeInfo = Object.GetType().GetTypeInfo();
            return (typeof(IList).GetTypeInfo().IsAssignableFrom(typeInfo));
        }

        /// &lt;summary&gt;
        /// Return true if object is number.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsNumber(object Object)
        {
            if (Object is int || Object is long || Object is decimal || Object is double) return true;
            return false;
        }

        /// &lt;summary&gt;
        /// Determines whether the specified type is simple type.
        /// Primitive types is Boolean, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, IntPtr, UIntPtr, Char, Double, Single, DateTime, decimal, string, Guid
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsSimpleType(object Object)
        {
            if (Object == null) return false;

            Type type = Object.GetType();
            TypeInfo typeInfo = type.GetTypeInfo();

            if (typeInfo.IsGenericType &amp;&amp; type.GetGenericTypeDefinition().Equals(typeof(Nullable&lt;&gt;))) type = Nullable.GetUnderlyingType(type);

            return typeInfo.IsPrimitive
                   || type == typeof(DateTime)
                   || type == typeof(decimal)
                   || type == typeof(string)
                   || type == typeof(Guid);
        }

        /// &lt;summary&gt;
        /// Test if the specified object is a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsString(object @Object)
        {
            var value = @Object is string;
            return value;
        }

        #region IsNull

        /// &lt;summary&gt;
        /// Check if Objects is null.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsNull(object Object)
        {
            string errorMsg = &quot;&quot;;
            return IsNull(Object, out errorMsg, errorMsg, false);
        }

        /// &lt;summary&gt;
        /// Check if Objects is null.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;param name=&quot;errorMsg&quot;&gt;The error MSG.&lt;/param&gt;
        /// &lt;param name=&quot;defaultErrorMsg&quot;&gt;The default error MSG.&lt;/param&gt;
        /// &lt;param name=&quot;showError&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [show error].&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsNull(object Object, out string errorMsg, string defaultErrorMsg = &quot;Error! object == null.&quot;, bool showError = true)
        {
            if (!_lamed.Types.Test.IsValidStr(defaultErrorMsg)) defaultErrorMsg = &quot;&quot;;

            //.if (Object == null || Word_FromAbbreviation.IsDBNull(Object))
            var result = false;
            if (Object == null) result = true;
            else
            {
                // Check for null strings
                var resultStr = Object as string;
                if (resultStr != null)
                {
                    if (resultStr == &quot;\u0002&quot; || resultStr == &quot;\0&quot;) result = true;
                }
            }
             
            if (result)
            {
                errorMsg = defaultErrorMsg;
                if (errorMsg != &quot;&quot; &amp;&amp; showError) _lamed.Exceptions.Show(errorMsg);
                
            } else errorMsg = &quot;&quot;;

            return result;

        }

        /// &lt;summary&gt;Check if Objects is null.&lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;param name=&quot;showError&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [show error].&lt;/param&gt;
        /// &lt;param name=&quot;errorMsg&quot;&gt;The error MSG.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsNull(object Object, bool showError, string errorMsg = &quot;Error! object == null.&quot;)
        {
            string notUsed;
            return IsNull(Object, out notUsed, errorMsg, showError);
        }

        #endregion

        /// &lt;summary&gt;
        /// Determines whether the specified type is structure.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Object&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public bool IsStruct(object Object)
        {
            TypeInfo typeInfo = Object.GetType().GetTypeInfo();
            return typeInfo.IsValueType &amp;&amp; !IsSimpleType(Object);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[191,103,191,143,0],[30,9,30,10,1],[31,13,31,81,1],[32,9,32,10,1],[38,9,38,10,1],[39,13,39,30,1],[40,9,40,10,1],[47,9,47,10,1],[48,13,48,53,1],[49,9,49,10,1],[57,9,57,10,1],[58,13,58,61,1],[59,9,59,10,1],[63,9,63,10,1],[64,13,64,65,1],[65,9,65,10,1],[73,9,73,10,1],[74,13,74,45,1],[74,46,74,81,1],[76,13,76,25,1],[77,9,77,10,1],[85,9,85,10,1],[86,13,86,31,1],[87,9,87,10,1],[96,9,96,10,1],[97,13,97,41,1],[98,9,98,10,1],[104,9,104,10,1],[105,13,105,42,1],[106,13,106,52,1],[107,13,107,37,1],[108,9,108,10,1],[117,9,117,10,1],[118,13,118,42,1],[119,13,119,52,1],[121,13,127,26,1],[128,9,128,10,1],[137,9,137,10,1],[138,13,138,42,1],[139,13,139,47,1],[140,13,140,83,1],[141,9,141,10,1],[149,9,149,10,1],[150,13,150,86,1],[151,9,151,10,1],[160,9,160,10,1],[161,13,161,59,1],[162,13,162,77,1],[163,9,163,10,1],[172,9,172,10,1],[173,13,173,90,1],[173,91,173,103,1],[174,13,174,26,1],[175,9,175,10,1],[185,9,185,10,1],[186,13,186,32,1],[186,33,186,46,1],[188,13,188,42,1],[189,13,189,52,1],[191,13,191,102,1],[193,13,197,44,1],[198,9,198,10,1],[206,9,206,10,1],[207,13,207,43,1],[208,13,208,26,1],[209,9,209,10,1],[219,9,219,10,1],[220,13,220,34,1],[221,13,221,66,1],[222,9,222,10,1],[233,9,233,10,1],[234,13,234,64,1],[234,65,234,86,1],[237,13,237,32,1],[238,13,238,32,1],[238,33,238,47,1],[240,13,240,14,1],[242,17,242,50,1],[243,17,243,39,1],[244,17,244,18,1],[245,21,245,68,1],[245,69,245,83,1],[246,17,246,18,1],[247,13,247,14,1],[249,13,249,24,1],[250,13,250,14,1],[251,17,251,44,1],[252,17,252,49,1],[252,50,252,83,1],[254,13,254,14,1],[254,20,254,34,1],[256,13,256,27,1],[258,9,258,10,1],[267,9,267,10,1],[269,13,269,69,1],[270,9,270,10,1],[281,9,281,10,1],[282,13,282,64,1],[283,13,283,66,1],[284,9,284,10,1],[21,9,21,70,1]]);
    </script>
  </body>
</html>